---
title: 基础动态规划优化
date: 2021-08-27 15:02:18
tags:
  - DP
categories: 学习笔记
author: Mr_Stranger_CW
mathjax: true
---

# $\color {#000FF0}{\text {完全背包}}$
###### ~~一个好用而且很快但是应用时出错改起来巨恶心的东西~~


------------

### 完全背包的定义：有个容量为$V$的包，有$N$种物品，每种物品有无限个，第$i$个物品的体积为$w_i$，价值为$c_i$，求把这些东西选择性的放入包中的最大价值。


------------
#####
如上定义，完全背包同种物品拥有无限个，这是一个比较 ~~阴间~~ 关键的问题点。

#### 但是，虽然拥有一种物品有无限个，因为背包容量的限制，同一物品的使用次数还有上限的，进而我们可以将其转化为多重背包求解

 多重背包的求解还是要转化为$01$背包，所以 ~~万物皆可01背包~~ 完全背包的解法本质还是$01$背包。
 
-------
### 大概思路讲的差不多了，下面来讲一下算法流程
与其他背包的求解一样，我们需要使用动态规划的方式来求解

$dp[i][j]$表示在前$i$种物品中，使用最多$j$点容量所能达到的最大(或最小)价值

然后将其按照多重背包的方式进行求解，在正常$01$背包的两层循环中添加一层$k$，用来枚举同种物品选的个数。
### 朴素代码$O(n*v\ast s )\ \ s$表示物品个数：
```cpp
for(int i=1;i<=n;i++){
        for(int j=0;j<=v;j++){
            dp[i][j]=dp[i-1][j];
            for(int k=0;k*c[i]<=j;k++){
                dp[i][j]=max(dp[i-1][j],dp[i-1][j-k*c[i]]+k*w[i]);
            }
        }
    }
    
```
因为完全背包可以被转化为多重背包，那么完全背包也是可以进行二进制优化的

##### 二进制优化原理：把$2^0,2^1,\cdots 2^k,o$个物品看做一个物品，其中$o$是数量不足二的下一次方数的剩余物品，这样就可以通过这些被”分组“过的物品组合出在物品总数内的所有数量，但是他单种总共只有$\log_2 s_i+1$（$s_i$表示第$i$种物品的个数）个物品,所以在枚举个数的时候会快很多。


### 多重背包二进制优化代码$O(n\ast v\ast log_2 s)$
```cpp
for(int i=1;i<=n;i++){
        int c,v,s;
        cin>>c>>v>>s;
        int u=1;
        while(s>=u){
            a[++p].c=u*c;
            a[p].v=v*u;
            s-=u;
            u*=2;
        }
        if(s>0){
            a[++p].c=s*c;
            a[p].v=s*v;
            
        }
    }
```

完全背包只需要将上面代码中的$s$，即物品个数改为$\lfloor\frac{v}{c_i}\rfloor$即可

二进制优化之后可以直接转化为$01$背包求解

与完全背包不同的是，多重背包受到容量和个数的双重限制，而完全背包不同，他仅受到空间限制，所以这使得完全背包的优化不能被多重背包所应用，而反过来可以。
## 现在来讲一下 ~~上流社会~~ 完全背包的专属特权
#### 完全背包的时间复杂度优化
根据上文中的完全背包基础代码，我们整理一下状态转移方程

得到关于$i,j$在判断物品$i$使用情况的状态转移方程：

$dp[i][j]=max(dp[i][j-1],dp[i-1][j-1\ast c_i]+1*w_i,dp[i-1][j- 2\ast c_i]+2\ast w_i ,\cdots ,dp[i-1][j- k\ast c_i]+k\ast w_i )$

此时我们将$j-c_i$带入，得到关于$i,j-c_i$的状态转移方程：

$dp[i][j-c_i]=max(dp[i][j-c_i-1],dp[i][j-2\ast c_i]+w[i] \cdots)$

这时我们可以发现，关于$i,j$的状态完全可以通过关于$i,j-c_i$的状态转移而来。

这样我们就可以开心的省下一个枚举。

优化后的递推方程：

$dp[i][j]=max(dp[i][j-1],dp[i][j-c_i]+w_i)$

上代码

### 完全背包最终优化$O(n \ast v)$

```cpp
for(int i=1;i<=n;i++){
        for(int j=0;j<=v;j++){
            dp[i][j]=dp[i-1][j];
		dp[i][j]=max(dp[i-1][j],dp[i][j-c[i]]+w[i]);
         
        }
    }
    
```
# 讲完了！！！！
个人博客中有例题：$<NOIP2014> D1 \ T3$ 飞扬的小鸟
  
  ~~如果没有那就是还没有写完，因为我需要先把完全背包写出来~~